# Error Handling & Debugging Guide for Payymo

This document outlines the error handling and debugging standards for the Payymo project, focusing on structured logging, error boundaries, correlation, and recovery practices.

## Structured Logging

### Logger Configuration

- **Backend**: Use Python's built-in logging module with JSON formatting
- **Frontend**: Use a consistent logging wrapper that formats to JSON in development

### Log Levels

- **ERROR**: Unrecoverable errors, crashes, failed API requests
- **WARNING**: Recoverable issues, potential problems, unexpected states, non-critical API failures
- **INFO**: Key application events (startup, config loaded, user login, resource creation)
- **DEBUG**: Detailed diagnostic information (only in development/staging)

### Context Fields

All logs should include relevant context fields as appropriate:

- **request_id**: Unique ID for tracing a request across services
- **user_id**: ID of the logged-in user (if available)
- **session_id**: Session identifier
- **component**: Frontend component or backend module where the log originated
- **operation**: Specific function or action being performed (e.g., connect_bank, fetch_transactions)
- **path**: API endpoint path or frontend route
- **method**: HTTP method (for API requests)
- **status_code**: HTTP status code (for API responses)
- **duration_ms**: Duration of an operation (e.g., API request)
- **error_code**: Application-specific error code (if applicable)
- **stack_trace**: (For error level) Stack trace of the error

### Logging Patterns

#### API Request Start (Backend - INFO)
```json
{
  "level": "INFO", 
  "timestamp": "2025-04-14T21:58:23.755Z", 
  "message": "API Request Start", 
  "method": "POST", 
  "path": "/api/v1/bank_connections", 
  "request_id": "xyz789", 
  "user_id": "user123"
}
```

#### API Request End (Backend - INFO/ERROR)
```json
{
  "level": "INFO", 
  "timestamp": "2025-04-14T21:58:24.755Z", 
  "message": "API Request End", 
  "method": "POST", 
  "path": "/api/v1/bank_connections", 
  "status_code": 201, 
  "duration_ms": 150, 
  "request_id": "xyz789", 
  "user_id": "user123"
}
```

```json
{
  "level": "ERROR", 
  "timestamp": "2025-04-14T21:58:24.755Z", 
  "message": "API Request Failed", 
  "method": "POST", 
  "path": "/api/v1/bank_connections", 
  "status_code": 500, 
  "duration_ms": 120, 
  "request_id": "xyz789", 
  "user_id": "user123", 
  "error": "Database connection failed", 
  "stack_trace": "..." 
}
```

## Error Boundary System (Flask)

- Use decorator patterns or middleware to catch errors at key application layers
- Log errors to a centralized logging service, including request_id in context
- Display user-friendly error pages instead of exposing technical errors
- Use Flask blueprints for error handling to separate concerns and improve maintainability

## Recovery UI

- Provide clear error messages to users (avoid technical jargon)
- Offer actionable steps (e.g., "Try again," "Contact support," "Go to dashboard")
- Include a unique error ID (the request_id shown to user) that can be mapped back to logs
- For banking connection errors, provide specific guidance based on common issues (e.g., invalid credentials, bank service unavailable)

## Error Correlation

- **Goal**: Trace a single user interaction or request across frontend, backend, and potentially other services
- **Mechanism**: Use a unique Request ID (also known as Correlation ID or Trace ID)

### Generation
- Generate a unique ID (e.g., UUID) when an operation starts
- For API requests, this can be generated by the API gateway or first service

### Propagation
- **Frontend**: Include the request_id in all log messages related to that operation
- **Backend**: Read the X-Request-ID header from incoming requests and include this request_id in all log messages
- **Services**: Propagate the request_id to any internal service calls

## Monitoring & Alerting

- Configure alerts for critical error spikes or performance degradation
- Set up monitoring for key application metrics:
  - Bank connection success/failure rates
  - Transaction retrieval success/failure rates
  - API response times
  - Authentication failures
  - Database query performance

## Known Error Registry

- Maintain a registry of known errors, their causes, and mitigation strategies
- Link error codes in user-facing messages to this registry where appropriate
- Include specific error handling for known external API errors (GoCardless, Stripe)

## Financial Transaction Error Handling

- Implement special care for financial transaction errors:
  - Always log the full context of any transaction-related error
  - Never silently fail on payment or transaction operations
  - Implement reconciliation processes to verify transaction integrity
  - Use transaction IDs for tracking and correlation
  - Store transaction attempts even when they fail for auditing purposes

## Multi-Tenant Error Isolation

- Ensure errors in one tenant context don't affect others
- Log the tenant ID with all errors
- Implement tenant-specific error policies if needed

## Debugging Tools

- **Development Environment**: Python debugger (pdb), Flask debug mode
- **Log Analysis**: Tools for searching and analyzing structured logs
- **API Testing**: Postman collections for testing API endpoints
- **Error Simulation**: Tools for simulating error conditions (network failures, API errors)

## Implementation Examples

### Flask Error Handler
```python
@app.errorhandler(Exception)
def handle_exception(e):
    # Get request ID from request context
    request_id = getattr(g, 'request_id', 'unknown')
    
    # Log the error with context
    app.logger.error(
        "Unhandled exception", 
        extra={
            "request_id": request_id,
            "path": request.path,
            "method": request.method,
            "error": str(e),
            "stack_trace": traceback.format_exc()
        }
    )
    
    # Return appropriate response
    if isinstance(e, HTTPException):
        return jsonify(error=str(e), request_id=request_id), e.code
    
    return jsonify(error="Internal server error", request_id=request_id), 500
```

### Request ID Middleware
```python
@app.before_request
def before_request():
    # Get or generate request ID
    g.request_id = request.headers.get('X-Request-ID') or str(uuid.uuid4())
    
    # Log request start
    app.logger.info(
        "API Request Start",
        extra={
            "request_id": g.request_id,
            "path": request.path,
            "method": request.method,
            "user_id": g.user.id if hasattr(g, 'user') else None
        }
    )

@app.after_request
def after_request(response):
    # Add request ID to response headers
    response.headers['X-Request-ID'] = g.request_id
    
    # Log request completion
    app.logger.info(
        "API Request End",
        extra={
            "request_id": g.request_id,
            "path": request.path,
            "method": request.method,
            "status_code": response.status_code,
            "duration_ms": request.endpoint_execution_time_ms if hasattr(request, 'endpoint_execution_time_ms') else None
        }
    )
    
    return response
```

## Appendix: Common Error Codes & Solutions

| Error Code | Description | Possible Causes | Recommended Action |
|------------|-------------|-----------------|-------------------|
| BANK-001 | Bank connection failed | Invalid credentials, bank service down | Verify credentials, try again later |
| BANK-002 | Transaction fetch failed | Connection timeout, permission issue | Check permissions, retry connection |
| STRIPE-001 | Payment processing failed | Invalid card, insufficient funds | Verify payment details, try alternative payment method |
| AUTH-001 | Authentication failed | Invalid credentials, expired token | Verify credentials, request new token |
| DB-001 | Database operation failed | Connection issue, constraint violation | Check database connection, verify data integrity |